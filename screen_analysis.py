# Methods for plotting and analyzing screen data tables generated by process_experiments.py

import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
import os
import sys
import numpy as np
import scipy as sp


##Matplotlib settings
almost_black = '#111111'
dark2 = ['#1b9e77',
'#d95f02',
'#7570b3',
'#e7298a',
'#66a61e',
'#e6ab02',
'#a6761d',
'#666666']
blue_yellow = matplotlib.colors.LinearSegmentedColormap.from_list('BuYl',[(0,'#ffff00'),(.49,'#000000'),(.51,'#000000'),(1,'#0000ff')])
blue_yellow.set_bad('#999999',1)
yellow_blue = matplotlib.colors.LinearSegmentedColormap.from_list('YlBu',[(0,'#0000ff'),(.49,'#000000'),(.51,'#000000'),(1,'#ffff00')])
yellow_blue.set_bad('#999999',1)

plt.rcParams['font.sans-serif'] = ['Helvetica', 'Arial']
plt.rcParams['font.size'] = 8
plt.rcParams['font.weight'] = 'regular'
plt.rcParams['text.color'] = almost_black

axisLineWidth = .5
plt.rcParams['axes.linewidth'] = axisLineWidth
plt.rcParams['lines.linewidth'] = 1.5

plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['axes.edgecolor'] = almost_black
plt.rcParams['axes.labelcolor'] = almost_black
# plt.rcParams['axes.color_cycle'] = dark2_all

plt.rcParams['patch.edgecolor'] = 'none'
plt.rcParams['patch.linewidth'] = .25
# plt.rcParams['patch.facecolor'] = dark2_all[0]

# plt.rcParams['savefig.dpi']=1000
# plt.rcParams['savefig.format'] = 'svg'

plt.rcParams['legend.frameon'] = False
plt.rcParams['legend.handletextpad'] = .25
plt.rcParams['legend.fontsize'] = 8
plt.rcParams['legend.numpoints'] = 1
plt.rcParams['legend.scatterpoints'] = 1

plt.rcParams['ytick.direction'] = 'out'
plt.rcParams['ytick.color'] = almost_black
plt.rcParams['ytick.major.width'] = axisLineWidth
plt.rcParams['xtick.direction'] = 'out'
plt.rcParams['xtick.color'] = almost_black
plt.rcParams['xtick.major.width'] = axisLineWidth

def loadData(experimentName, collapsedToTranscripts = True):
    dataDict = {'library': pd.read_csv(experimentName + '_librarytable.txt',sep='\t',header=0,index_col=0),
    'counts': pd.read_csv(experimentName + '_mergedcountstable.txt',sep='\t',header=range(2),index_col=range(1)),
    'phenotypes': pd.read_csv(experimentName + '_phenotypetable.txt',sep='\t',header=range(2),index_col=range(1))}
    
    if collapsedToTranscripts:
        dataDict['transcript scores'] = pd.read_csv(experimentName + '_genetable.txt',sep='\t',header=range(3),index_col=range(2))
    
    dataDict['gene scores'] = pd.read_csv(experimentName + '_genetable_collapsed.txt',sep='\t',header=range(3),index_col=range(1))
    
    return dataDict


##read counts-level plotting functions
def countsHistogram(data, condition=None, replicate=None):
    if not checkOptions(data, 'counts', (phenotype,replicate)):
        return
        
    fig, axis = plt.subplots(figsize=(3.5,2.5))
    cleanAxes(axis)
    
    axis.hist(np.log2(data['counts'].loc[:, (condition, replicate)].dropna() + 1), 
        bins=int(len(data['counts']) ** .3), 
        histtype='stepfilled', color=almost_black)
    
#     axis.set_xlim((-0.1, axis.get_xlim()[1])) 
    
    axis.set_xlabel('{0} {1} sgRNA read counts (log2)'.format(condition, replicate))
    axis.set_ylabel('Number of sgRNAs')
    
    plt.tight_layout()
    fig.show()
    
def countsScatter(data, condition_x = None, replicate_x = None,
                        condition_y = None, replicate_y = None,
                        showAll = True, showNegatives = True, showGenes = [],
                        colorByPhenotype_condition = None, colorByPhenotype_replicate = None):
                            
    if not checkOptions(data, 'counts', (condition_x,replicate_x)):
        return
    if not checkOptions(data, 'counts', (condition_y,replicate_y)):
        return
    if colorByPhenotype_condition != None and colorByPhenotype_replicate != None \
        and not checkOptions(data, 'phenotypes', (colorByPhenotype_condition,colorByPhenotype_replicate)):
        return 
        
    fig, axis = plt.subplots(figsize=(3,3))
    cleanAxes(axis)
    
    if showAll:
        if colorByPhenotype_condition == None or colorByPhenotype_replicate == None:
            axis.scatter(np.log2(data['counts'].loc[:, (condition_x, replicate_x)] + 1), 
                np.log2(data['counts'].loc[:, (condition_y, replicate_y)] + 1), 
                s=1.5, c=almost_black, label='all sgRNAs')
        else:
            result = axis.scatter(np.log2(data['counts'].loc[:, (condition_x, replicate_x)] + 1), 
                np.log2(data['counts'].loc[:, (condition_y, replicate_y)] + 1), 
                s=1.5, c=data['phenotypes'].loc[:, (colorByPhenotype_condition,colorByPhenotype_replicate)],
                cmap=yellow_blue, label='all sgRNAs')
                
            plt.colorbar(result)
    
    if showNegatives:
        axis.scatter(np.log2(data['counts'].loc[data['library']['gene'] == 'negative_control', (condition_x, replicate_x)] + 1), 
            np.log2(data['counts'].loc[data['library']['gene'] == 'negative_control', (condition_y, replicate_y)] + 1), 
            s=1.5, c='#BFBFBF', label='non-targeting sgRNAs')
            
    if showGenes and len(showGenes) != 0:
        if isinstance(showGenes,str):
            showGenes = [showGenes]
            
        geneSet = set(data['library']['gene'])
        for i, gene in enumerate(showGenes):
            if gene not in geneSet:
                print '{0} not in dataset'.format(gene)
            else:
                axis.scatter(np.log2(data['counts'].loc[data['library']['gene'] == gene, (condition_x, replicate_x)] + 1), 
                    np.log2(data['counts'].loc[data['library']['gene'] == gene, (condition_y, replicate_y)] + 1), 
                    s=3, c=dark2[i], label=gene)
                    
    plt.legend(loc='best', fontsize=6, handletextpad=0.005)
    
    axis.set_xlim((-0.2, max(axis.get_xlim()[1],axis.get_ylim()[1]))) 
    axis.set_ylim((-0.2, max(axis.get_xlim()[1],axis.get_ylim()[1]))) 
    
    axis.set_xlabel('{0} {1} sgRNA read counts (log2)'.format(condition_x, replicate_x), fontsize=8)
    axis.set_ylabel('{0} {1} sgRNA read counts (log2)'.format(condition_y, replicate_y), fontsize=8)
    
    plt.tight_layout()
    fig.show()

##phenotype-level plotting functions
#not yet implemented: counts vs phenotype

def phenotypeHistogram(data, phenotype=None, replicate=None):
    if not checkOptions(data, 'phenotypes', (phenotype,replicate)):
        return
        
    fig, axis = plt.subplots(figsize=(3.5,2.5))
    cleanAxes(axis)
    
    axis.semilogy()
    
    axis.hist([data['phenotypes'].loc[:, (phenotype, replicate)].dropna(), 
                data['phenotypes'].loc[data['library']['gene'] == 'negative_control', (phenotype, replicate)].dropna()],
        bins=int(len(data['phenotypes']) ** .3), 
        histtype='step', color=[almost_black, '#BFBFBF'], label=['all sgRNAs', 'non-targeting sgRNAs'], lw=1)
        
    plt.legend(fontsize=6, loc='upper left')
    
    axis.set_ylim((0.9, axis.get_ylim()[1])) 
    
    axis.set_xlabel('{0} {1} sgRNA phenotypes'.format(phenotype, replicate))
    axis.set_ylabel('Number of sgRNAs')
    
    plt.tight_layout()
    fig.show()

def phenotypeScatter(data, phenotype_x = None, replicate_x = None,
                        phenotype_y = None, replicate_y = None,
                        showAll = True, showNegatives = True, 
                        showGenes = [], showGeneSets = {}):
                            
    if not checkOptions(data, 'phenotypes', (phenotype_x,replicate_x)):
        return
    if not checkOptions(data, 'phenotypes', (phenotype_y,replicate_y)):
        return
        
    fig, axis = plt.subplots(figsize=(3,3))
    cleanAxes(axis)
    
    if showAll:
        axis.scatter(data['phenotypes'].loc[:, (phenotype_x, replicate_x)], 
            data['phenotypes'].loc[:, (phenotype_y, replicate_y)], 
            s=1.5, c=almost_black, label='all sgRNAs')
    
    if showNegatives:
        axis.scatter(data['phenotypes'].loc[data['library']['gene'] == 'negative_control', (phenotype_x, replicate_x)], 
            data['phenotypes'].loc[data['library']['gene'] == 'negative_control', (phenotype_y, replicate_y)], 
            s=1.5, c='#BFBFBF', label='non-targeting sgRNAs')
            
    i=0
    if showGenes and len(showGenes) != 0:
        if isinstance(showGenes,str):
            showGenes = [showGenes]
            
        geneSet = set(data['library']['gene'])
        for i, gene in enumerate(showGenes):
            if gene not in geneSet:
                print '{0} not in dataset'.format(gene)
            else:
                axis.scatter(data['phenotypes'].loc[data['library']['gene'] == gene, (phenotype_x, replicate_x)], 
                    data['phenotypes'].loc[data['library']['gene'] == gene, (phenotype_y, replicate_y)], 
                    s=3, c=dark2[i], label=gene)
                    
    if showGeneSets and len(showGeneSets) != 0:
        if not isinstance(showGeneSets,dict) or not \
            (isinstance(showGeneSets[showGeneSets.keys()[0]], set) or isinstance(showGeneSets[showGeneSets.keys()[0]], list)):
            print 'Gene sets must be a dictionary of {set_name: [gene list/set]} pairs'
            
        else:
            for j, gs in enumerate(showGeneSets):
                sgsTargetingSet = data['library']['gene'].apply(lambda gene: gene in showGeneSets[gs])
                axis.scatter(data['phenotypes'].loc[sgsTargetingSet, (phenotype_x, replicate_x)], 
                    data['phenotypes'].loc[sgsTargetingSet, (phenotype_y, replicate_y)], 
                    s=3, c=dark2[i+j], label=gs)
                    
    plotGrid(axis)
                    
    plt.legend(loc='best', fontsize=6, handletextpad=0.005)
    
    axis.set_xlabel('sgRNA {0} {1}'.format(phenotype_x, replicate_x), fontsize=8)
    axis.set_ylabel('sgRNA {0} {1}'.format(phenotype_y, replicate_y), fontsize=8)
    
    plt.tight_layout()
    fig.show()

##gene-level plotting functions
def volcanoPlot(data, phenotype=None, replicate=None, transcripts=False, showPseudo=True):
    if not checkOptions(data, 'genes', (phenotype,replicate)):
        return



##utility functions
def checkOptions(data, graphType, optionTuple):
    if optionTuple[0] == None or optionTuple[1] == None:
        listOptions(data, graphType)
        return False
        
    if graphType == 'counts':
        colTups = set([colname[:2] for colname, col in data['counts'].iteritems()])
    elif graphType == 'phenotypes':
        colTups = set([colname[:2] for colname, col in data['phenotypes'].iteritems()])
    elif graphType == 'genes':
        colTups = set([colname[:2] for colname, col in data['gene scores'].iteritems()])
    else:
        print 'Graph type not recognized'
        return False

    if optionTuple in colTups:
        return True
    else:
        print '{0} {1} not recognized'.format(optionTuple[0],optionTuple[1])
        listOptions(data, graphType)
        return False


def listOptions(data, graphType):
    if graphType == 'counts':
        print 'Condition and Replicate options are:'
        print '\n'.join(['{0:15}\t{1}'.format(colname[0],colname[1]) for colname, col in data['counts'].iteritems()])
        
    elif graphType == 'phenotypes':
        print 'Phenotype and Replicate options are:'
        print '\n'.join(['{0:15}\t{1}'.format(colname[0],colname[1]) for colname, col in data['phenotypes'].iteritems()])
        
    elif graphType == 'genes':
        colTups = sorted(list(set([colname[:2] for colname, col in data['gene scores'].iteritems()])))
        print 'Phenotype and Replicate options are:'
        print '\n'.join(['{0:15}\t{1}'.format(colname[0],colname[1]) for colname in colTups])
        
    else:
        print 'Graph type not recognized'
    
def plotGrid(axis, vert_origin = True, horiz_origin=True, unity=True):
    ylim = axis.get_ylim()
    xlim = axis.get_xlim()
    if vert_origin:
        axis.plot((0,0), ylim, color='#BFBFBF', lw=.5, alpha=.5) 
    if horiz_origin:
        axis.plot(xlim,(0,0), color='#BFBFBF', lw=.5, alpha=.5) 
    if vert_origin:
        xmin = min(xlim[0], ylim[0])
        xmax = max(xlim[1], ylim[1])
        axis.plot((xmin,xmax),(xmin,xmax), color='#BFBFBF', lw=.5, alpha=.5) 
        
    axis.set_ylim(ylim)
    axis.set_xlim(xlim)

#adapted from http://nbviewer.ipython.org/github/cs109/content/blob/master/lec_03_statistical_graphs.ipynb    
def cleanAxes(axis, top=False, right=False, bottom=True, left=True):
    axis.spines['top'].set_visible(top)
    axis.spines['right'].set_visible(right)
    axis.spines['left'].set_visible(left)
    axis.spines['bottom'].set_visible(bottom)

    #turn off all ticks
    axis.yaxis.set_ticks_position('none')
    axis.xaxis.set_ticks_position('none')

    #now re-enable visibles
    if top:
        axis.xaxis.tick_top()
    if bottom:
        axis.xaxis.tick_bottom()
    if left:
        axis.yaxis.tick_left()
    if right:
        axis.yaxis.tick_right()

# def rasteredScatter(series1,series2,label1,label2,outfilename):
#     # print outfilename
#     pass
# 
# def generateHistogram(series, label, outfilename):
#     pass